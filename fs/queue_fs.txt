STATE before_parse
    CREATE self_ref_struct ""
    CREATE self_ref_ptr ""
    CREATE key_name ""
    COMMENT Assuming just one self-refer pointer and one key in list node
    CREATE new_node_name ""
    CREATE last_node_name ""
    CREATE insertion_at_end_func ""
    CREATE q_struct_name ""
    CREATE q_head_name ""
    CREATE deletion_at_begin_func ""
    CREATE deq_params []
    CREATE enq_params []
    CREATE cur_func_name ""
    CREATE main_func_lineno -1
    CREATE common_arg False
END_STATE

STATE structures_and_unions
    USE_GLOBAL self_ref_struct
    USE_GLOBAL self_ref_ptr
    USE_GLOBAL key_name
    USE_GLOBAL q_struct_name
    USE_GLOBAL q_head_name
    IF 'struct' IN EXP
        COMMENT Checking only struct declarations, not unions.
        IF self_ref_struct EQUALTO ""
            FOR memb IN STRUCT_MEMBERS
                SET t "type"
                SET d "declarators"
                COMMENT 'INDEX memb "type"' is invalid as memb_"type" is not a valid identifier
                INDEX memb t
                INDEX memb d
                IF NAME IN memb_t
                    SET self_ref_struct NAME
                    FOR i IN range(len(memb_d))
                        INDEX memb_d i
                        IF memb_d_i.isidentifier() EQUALTO True
                            SET self_ref_ptr memb_d_i
                            BREAK
                        END_IF
                    END_FOR
                ELSE
                    FOR i IN range(len(memb_d))
                        INDEX memb_d i
                        IF memb_d_i.isidentifier() EQUALTO True
                            SET key_name memb_d_i
                            BREAK
                        END_IF
                    END_FOR
                END_IF
            END_FOR
        ELSE
            IF q_struct_name EQUALTO ""
                IF self_ref_struct NOTEQUALTO ""
                    FOR memb IN STRUCT_MEMBERS
                        SET t "type"
                        SET d "declarators"
                        INDEX memb t
                        INDEX memb d
                        IF self_ref_struct IN memb_t
                            SET q_struct_name NAME
                            FOR i IN range(len(memb_d))
                                INDEX memb_d i
                                IF memb_d_i.isidentifier() EQUALTO True
                                    SET q_head_name memb_d_i
                                    BREAK
                                END_IF
                            END_FOR
                        END_IF
                    END_FOR
                END_IF
            END_IF
        END_IF
    END_IF
END_STATE

STATE variable_assignments
    USE_GLOBAL new_node_name
    USE_GLOBAL insertion_at_end_func
    USE_GLOBAL deletion_at_begin_func
    IF '=' IN EXP
        IF new_node_name EQUALTO ""
            IF 'malloc' IN RHS
                SET new_node_name NAME    
            ELSE
                IF 'calloc' IN RHS
                    SET new_node_name NAME
                END_IF
            END_IF  
        END_IF 
        IF last_node_name IS_TRUE
            IF last_node_name IN LHS
                IF '->' IN LHS
                    IF self_ref_ptr IN LHS
                        IF new_node_name IN RHS
                            SET insertion_at_end_func cur_func_name
                        END_IF
                    END_IF
                END_IF
            END_IF
        END_IF
        
        IF '->' IN LHS
            IF q_head_name IN LHS
                IF q_head_name IN RHS
                    IF '->' IN RHS
                        IF self_ref_ptr IN RHS
                            SET deletion_at_begin_func cur_func_name
                        END_IF
                    END_IF
                END_IF
            END_IF
        END_IF
    END_IF
END_STATE

STATE function_header
    USE_GLOBAL cur_func_name
    USE_GLOBAL main_func_lineno
    SET cur_func_name NAME
    IF NAME EQUALTO 'main'
        SET main_func_lineno LINE
    END_IF
END_STATE


STATE initialized_declaration
    USE_GLOBAL new_node_name
    IF 'malloc' IN RHS
        SET new_node_name NAME    
    ELSE
        IF 'calloc' IN RHS
            SET new_node_name NAME
        END_IF
    END_IF  
END_STATE

STATE function_call
    USE_GLOBAL insertion_at_end_func
    USE_GLOBAL deletion_at_begin_func
    USE_GLOBAL enq_params
    USE_GLOBAL deq_params
    USE_GLOBAL common_arg
    IF NAME EQUALTO insertion_at_end_func
        SET enq_params FUNC_ARGS
        IF deq_params IS_TRUE
            IF set(enq_params)-set(deq_params) NOTEQUALTO enq_params
                COMMENT enQueue() and deQueue() have a common argument
                SET common_arg True
            END_IF
        END_IF
    END_IF   
    IF NAME EQUALTO deletion_at_begin_func  
        SET deq_params FUNC_ARGS
        IF enq_params IS_TRUE
            IF set(enq_params)-set(deq_params) NOTEQUALTO enq_params
                COMMENT enQueue() and deQueue() have a common argument
                SET common_arg True
            END_IF
        END_IF
    END_IF
END_STATE


STATE loop_statement
    USE_GLOBAL self_ref_ptr
    USE_GLOBAL last_node_name
    SET m re.search(r"(.*)=(\1)->{}".format(self_ref_ptr),"".join(EXP))
    IF m IS_TRUE
        SET last_node_name m.groups()[0]
    END_IF
END_STATE

STATE after_parse
    IF self_ref_struct IS_FALSE
        PRINT main_func_lineno
        VIOLATION Linked list not found
    ELSE
        IF insertion_at_end_func IS_FALSE
            PRINT main_func_lineno
            VIOLATION Function for insertion at end not found
        END_IF
        IF deletion_at_begin_func IS_FALSE
                PRINT main_func_lineno
                VIOLATION Function for deletion at beginning not found
            END_IF
        END_IF
        
        IF insertion_at_end_func IS_TRUE
            IF deletion_at_begin_func IS_TRUE
                IF common_arg IS_FALSE
                    PRINT main_func_lineno
                    VIOLATION Could not find a variable on which insertion at end AND deletion at beginning are performed
                END_IF
            END_IF
        END_IF
    END_IF
END_STATE




